<#@ assembly name="System.Core" #>
<#@ import namespace="System.CodeDom" #>
<#@ import namespace="System.CodeDom.Compiler" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="Microsoft.CSharp" #>
<#@ import namespace="System.Reflection" #>
<#+
    internal string NamespaceName = null;
    internal string ClassName = null;
    internal List<SettingsProperty> Settings = new List<SettingsProperty>();

    internal static Dictionary<Type, Func<object, string>> Formatters =
        new Dictionary<Type, Func<object, string>>()
            {
               { typeof (bool), x => x.ToString().ToLower() },
               { typeof (bool?), x => x == null ? "null" : x.ToString().ToLower() },
               { typeof (int), x => x.ToString() },
               { typeof (int?), x => x == null ? "null" : x.ToString() },
               { typeof (float), x => x.ToString() },
               { typeof (float?), x => x == null ? "null" : x.ToString() },
               { typeof (double), x => x.ToString() },
               { typeof (double?), x => x == null ? "null" : x.ToString() },
               { typeof (decimal), x => x.ToString() },
               { typeof (decimal?), x => x == null ? "null" : x.ToString() },
               { typeof (string), x => FormatString((string)x) },
               { typeof (DateTime), x => FormatDateTime((DateTime)x) },
               { typeof (DateTime?), x => x == null ? "null" : FormatDateTime((DateTime)x) },
               { typeof (TimeSpan), x => FormatTimeSpan((TimeSpan)x) },
               { typeof (TimeSpan?), x => x == null ? "null" : FormatTimeSpan((TimeSpan)x) },
            };

    private static string FormatDateTime(DateTime d)
    {
        return string.Format("new DateTime({0},{1},{2},{3},{4},{5})", d.Year, d.Month, d.Day, d.Hour, d.Minute, d.Second);
    }

    private static string FormatTimeSpan(TimeSpan t)
    {
        return string.Format("new TimeSpan({0})", t.Ticks);
    }

    private static string FormatString(string s)
    {
        using (var writer = new StringWriter())
        using (var provider = CodeDomProvider.CreateProvider("CSharp"))
        {
            provider.GenerateCodeFromExpression(new CodePrimitiveExpression(s), writer, null);
            return writer.ToString();
        }
    }

    internal class SettingsProperty
    {
        public string Name { get; protected set; }
        public string TypeName { get; protected set; }
        public string Default { get; protected set; }
    }

    internal class SettingsProperty<T> : SettingsProperty
    {
        public SettingsProperty(string name, T defaultValue)
        {
            Name = name;  
            TypeName = GetTypeName();

            Func<object, string> formatter;
            var type = typeof (T);
            if (!Formatters.TryGetValue(type, out formatter))
                throw new NotImplementedException("Type not supported: " + type.FullName);
            Default = formatter(defaultValue);
        }

        private string GetTypeName()
        {
            using (var p = new Microsoft.CSharp.CSharpCodeProvider())
                return p.GetTypeOutput(new CodeTypeReference(typeof (T)));
        }
    }

    private void Generate()
    {
        TrimOutput();

        WriteComment(
            @"----------------------------------------------------------------------------------------------------
    <auto-generated>
    This code was generated by SettingsGenerator template.
    Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
    </auto-generated>
----------------------------------------------------------------------------------------------------");

        WriteUsing(
            "System",
            "System.Collections.Generic",
            "System.Collections.ObjectModel",
            "Com.O2Bionics.ChatService.DataModel",
            "Com.O2Bionics.ChatService.Settings");

        WriteLine("namespace {0} {{", NamespaceName);

        WriteReadOnlySettingsClass();
        WriteWritableSettingsClass();

        WriteLine("}");
    }

    private void WriteReadOnlySettingsClass()
    {
        WriteLine("");
        WriteLine("public partial class {0} : SettingsBase {{", ClassName);

        WriteLine("");
        WriteLine(
            @"public static readonly ReadOnlyDictionary<string, SettingsPropertyDescriptor> PropertyDescriptors =
new ReadOnlyDictionary<string, SettingsPropertyDescriptor>(
new Dictionary<string, SettingsPropertyDescriptor> {");
        foreach (var p in Settings)
            WriteLine("{{ \"{0}\", new SettingsPropertyDescriptor<{1}>({2}) }},", p.Name, p.TypeName, p.Default);
        WriteLine("});");

        WriteLine("");
        WriteLine("public {0}(ICollection<PROPERTY_BAG> records) : base(records, PropertyDescriptors) {{}}", ClassName);
        WriteLine("public {0}(Writable{0} settings) : base(settings) {{}}", ClassName);

        foreach (var p in Settings) WriteProperty(p, false);

        WriteLine("}");
    }

    private void WriteWritableSettingsClass()
    {
        WriteLine("");
        WriteLine("public partial class Writable{0} : WritableSettingsBase {{", ClassName);

        WriteLine("");
        WriteLine("public Writable{0}({0} settings) : base(settings) {{}}", ClassName);
        WriteLine("public Writable{0}() : base({0}.PropertyDescriptors) {{}}", ClassName);

        foreach (var p in Settings) WriteProperty(p, true);

        WriteLine("}");
    }

    private void WriteProperty(SettingsProperty p, bool isWritable)
    {
        WriteLine("");

        WriteLine("public {1} {0} {{", p.Name, p.TypeName);
        WriteLine("get {{ return Get<{1}>(\"{0}\"); }}", p.Name, p.TypeName);
        if (isWritable)
            WriteLine("set {{ Set(\"{0}\", value); }}", p.Name);
        WriteLine("}");

        WriteLine("public bool Has{0} {{", p.Name);
        WriteLine("get {{ return Has(\"{0}\"); }}", p.Name);
        WriteLine("}");

        WriteLine("public {1} {0}Default {{", p.Name, p.TypeName);
        WriteLine("get {{ return Default<{1}>(\"{0}\"); }}", p.Name, p.TypeName);
        WriteLine("}");
    }

    private void WriteUsing(params string[] names)
    {
        foreach (var name in names) WriteLine("using {0};", name);
        WriteLine("");
    }

    private void WriteComment(string s)
    {
        var lines = s.Split(new[] { Environment.NewLine }, StringSplitOptions.None);
        foreach (var l in lines) WriteLine("//{0}", l);
    }

    private void TrimOutput()
    {
        if (GenerationEnvironment.Length > 0 && GenerationEnvironment.ToString().Trim().Length == 0)
            GenerationEnvironment.Length = 0;
    }

#>